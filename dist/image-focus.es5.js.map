{"version":3,"file":"image-focus.es5.js","sources":["../src/lib/helpers/assignStyles.ts","../src/lib/helpers/firstNumberIn.ts","../src/lib/helpers/debounce.ts","../src/lib/FocusedImage.ts","../src/lib/polyfills.ts","../src/lib/helpers/noop.ts","../src/lib/FocusPicker.ts"],"sourcesContent":["const VENDORS = [\"webkit\", \"Moz\", \"ms\"]\n\nexport function assignStyles(el: HTMLElement | SVGElement, styles: {}) {\n  for (const key in styles) {\n    el.style[key] = styles[key]\n  }\n}\n","export function firstNumberIn(values: (string | number)[]): number {\n  return values\n    .map(value => (typeof value === \"string\" ? parseFloat(value) : value))\n    .find(value => typeof value === \"number\")\n}\n","export function debounce(func: Function, debounceTime: number) {\n  let timeout: any\n  function debouncedFunction(...args) {\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n    timeout = setTimeout(() => func(...args), debounceTime)\n  }\n  return debouncedFunction\n}\n","import \"./polyfills\"\nimport { Cancelable } from \"lodash\"\n\nimport { debounce } from \"./helpers/debounce\"\nimport { assignStyles } from \"./helpers/assignStyles\"\n\nconst IMG_STYLES = {\n  minHeight: \"100%\",\n  minWidth: \"100%\",\n  position: \"absolute\",\n  top: \"0\",\n  right: \"0\",\n  bottom: \"0\",\n  left: \"0\",\n}\n\nconst CONTAINER_STYLES = {\n  position: \"relative\",\n  overflow: \"hidden\",\n}\n\nexport interface FocusedImageOptions {\n  /**\n   * Time in MS before debounceApplyShift fires\n   *\n   * Defaults to `17`\n   */\n  debounceTime?: number\n  /**\n   * Should window resize events fire debounceApplyShift?\n   *\n   * Defaults to `true`\n   */\n  updateOnWindowResize?: boolean\n  /**\n   * Focus coordinates to initialize with\n   *\n   * Default value is `undefined`\n   */\n  focus?: {\n    x: number\n    y: number\n  }\n}\n\nexport interface HTMLImageElementWithFocalPoint extends HTMLImageElement {\n  __focal_point_instance__: FocusedImage\n}\n\nconst DEFAULT_OPTIONS: FocusedImageOptions = {\n  debounceTime: 17,\n  updateOnWindowResize: true,\n}\n\nexport class FocusedImage {\n  options: FocusedImageOptions\n  container: HTMLElement\n  img: HTMLImageElementWithFocalPoint\n  listening: boolean\n  debounceApplyShift: () => void\n\n  constructor(private initializationNode: HTMLElement | HTMLImageElement, options?: FocusedImageOptions) {\n    this.options = Object.assign(DEFAULT_OPTIONS, options)\n    this.setUpElementReferences(initializationNode)\n    this.setUpStyles()\n    this.debounceApplyShift = debounce(this.applyShift, this.options.debounceTime)\n    if (this.options.focus) {\n      this.setFocusAttributes(this.options.focus.x, this.options.focus.y)\n    }\n    if (this.options.updateOnWindowResize) {\n      this.startListening()\n    }\n    // applyShift async to allow container styles to recalculate\n    setTimeout(() => this.applyShift(), 0)\n  }\n\n  public setFocus = (x: number, y: number) => {\n    this.setFocusAttributes(x, y)\n    this.applyShift()\n  }\n\n  public applyShift = () => {\n    // Check a couple things to alert at dev time of problems\n    if (!this.hasReferences()) {\n      // bail if no references\n      return\n    }\n    this.checkForStaticPosition()\n\n    const imageW = this.img.naturalWidth\n    const imageH = this.img.naturalHeight\n    const containerW = this.container.getBoundingClientRect().width\n    const containerH = this.container.getBoundingClientRect().height\n    const focusX = parseFloat(this.img.getAttribute(\"data-focus-x\") as string)\n    const focusY = parseFloat(this.img.getAttribute(\"data-focus-y\") as string)\n\n    // Amount position will be shifted\n    let hShift = \"0\"\n    let vShift = \"0\"\n\n    if (!(containerW > 0 && containerH > 0 && imageW > 0 && imageH > 0)) {\n      return false // Need dimensions to proceed\n    }\n\n    // Which is over by more?\n    const wR = imageW / containerW\n    const hR = imageH / containerH\n\n    // Reset max-width and -height\n    this.img.style.maxHeight = null\n    this.img.style.maxWidth = null\n\n    // Minimize image while still filling space\n    if (imageW > containerW && imageH > containerH) {\n      this.img.style[wR > hR ? \"maxHeight\" : \"maxWidth\"] = \"100%\"\n    }\n\n    if (wR > hR) {\n      hShift = this.calcShift(hR, containerW, imageW, focusX)\n    } else if (wR < hR) {\n      vShift = this.calcShift(wR, containerH, imageH, focusY, true)\n    }\n\n    this.img.style.top = vShift\n    this.img.style.left = hShift\n  }\n\n  public startListening() {\n    if (this.listening) {\n      return\n    }\n    this.listening = true\n    window.addEventListener(\"resize\", this.debounceApplyShift)\n  }\n\n  public stopListening() {\n    if (!this.listening) {\n      return\n    }\n    this.listening = false\n    window.removeEventListener(\"resize\", this.debounceApplyShift)\n  }\n\n  private setFocusAttributes = (x: number, y: number) => {\n    this.img.setAttribute(\"data-focus-x\", x.toString())\n    this.img.setAttribute(\"data-focus-y\", y.toString())\n  }\n\n  private setUpStyles() {\n    assignStyles(this.container, CONTAINER_STYLES)\n    assignStyles(this.img, IMG_STYLES)\n  }\n\n  private checkForStaticPosition() {\n    if (this.container.style.position === \"static\") {\n      console.warn(`\nThis container has a static position. The image will not\nbe contained properly unless it has a non-static position\nsuch as 'absolute' or 'relative'.`)\n    }\n  }\n\n  private hasReferences() {\n    let hasReferences = true\n    if (!this.img) {\n      hasReferences = false\n      console.error(`\nReference to image not found. Make sure the container\nhas an image inside it.\n`)\n    }\n    if (!this.container) {\n      hasReferences = false\n      console.error(`\nReference to container not found. Not sure how that happened.\n`)\n    }\n    return hasReferences\n  }\n\n  private setUpElementReferences(initializationNode: HTMLElement | HTMLImageElement) {\n    if (initializationNode.nodeName === \"IMG\") {\n      this.img = initializationNode as HTMLImageElementWithFocalPoint\n      this.container = initializationNode.parentElement as HTMLElement\n    } else {\n      this.container = initializationNode as HTMLElement\n      this.img = initializationNode.querySelector(\"img\") as HTMLImageElementWithFocalPoint\n      if (!this.img) {\n        console.error(initializationNode)\n        throw new Error(\"No image found within above container\")\n      }\n    }\n    if (this.img.__focal_point_instance__) {\n      this.img.__focal_point_instance__.stopListening()\n    }\n    this.img.__focal_point_instance__ = this\n    this.img.onload = this.applyShift\n  }\n\n  // Calculate the new left/top values of an image\n  private calcShift(\n    conToImageRatio: number,\n    containerSize: number,\n    imageSize: number,\n    focusSize: number,\n    toMinus?: boolean,\n  ) {\n    const containerCenter = Math.floor(containerSize / 2) // Container center in px\n    const focusFactor = (focusSize + 1) / 2 // Focus point of resize image in px\n    const scaledImage = Math.floor(imageSize / conToImageRatio) // Can't use width() as images may be display:none\n    let focus = Math.floor(focusFactor * scaledImage)\n    if (toMinus) focus = scaledImage - focus\n    let focusOffset = focus - containerCenter // Calculate difference between focus point and center\n    const remainder = scaledImage - focus // Reduce offset if necessary so image remains filled\n    const containerRemainder = containerSize - containerCenter\n    if (remainder < containerRemainder) focusOffset -= containerRemainder - remainder\n    if (focusOffset < 0) focusOffset = 0\n\n    return focusOffset * -100 / containerSize + \"%\"\n  }\n}\n\nexport function initFocusedImage(el) {\n  return new FocusedImage(el)\n}\n","// Polyfill for Object.assign\nif (typeof Object.assign !== \"function\") {\n  // Must be writable: true, enumerable: false, configurable: true\n  Object.defineProperty(Object, \"assign\", {\n    value: function assign(target, varArgs) {\n      // .length of function is 2\n      \"use strict\"\n      if (target == null) {\n        // TypeError if undefined or null\n        throw new TypeError(\"Cannot convert undefined or null to object\")\n      }\n\n      const to = Object(target)\n\n      for (let index = 1; index < arguments.length; index++) {\n        const nextSource = arguments[index]\n\n        if (nextSource != null) {\n          // Skip over if undefined or null\n          for (const nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey]\n            }\n          }\n        }\n      }\n      return to\n    },\n    writable: true,\n    configurable: true,\n  })\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.find\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, \"find\", {\n    value: function(predicate) {\n      // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined')\n      }\n\n      const o = Object(this)\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      const len = o.length >>> 0\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== \"function\") {\n        throw new TypeError(\"predicate must be a function\")\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      const thisArg = arguments[1]\n\n      // 5. Let k be 0.\n      let k = 0\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return kValue.\n        const kValue = o[k]\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue\n        }\n        // e. Increase k by 1.\n        k++\n      }\n\n      // 7. Return undefined.\n      return undefined\n    },\n  })\n}\n","// tslint:disable-next-line:no-empty\nexport const noop = () => {}\n","import \"./polyfills\"\n\nimport { assignStyles } from \"./helpers/assignStyles\"\nimport { firstNumberIn } from \"./helpers/firstNumberIn\"\nimport { noop } from \"./helpers/noop\"\n\nimport retina from \"./retina.svg\"\n\nconst IMAGE_STYLES = {\n  display: \"block\",\n  maxWidth: \"100%\",\n}\n\nconst CONTAINER_STYLES = {\n  position: \"relative\",\n  overflow: \"hidden\",\n  userSelect: \"none\",\n}\n\nconst RETINA_STYLES = {\n  position: \"absolute\",\n  cursor: \"move\",\n}\n\nconst DEFAULT_OPTIONS: FocusPickerOptions = {\n  onChange: noop,\n}\n\nexport interface FocusPickerOptions {\n  onChange?: (x: number, y: number) => void\n  focus?: {\n    x: number\n    y: number\n  }\n}\n\nexport class FocusPicker {\n  container: HTMLElement\n  img: HTMLImageElement\n  retina: HTMLImageElement\n  isDragging: boolean\n  focusX: number\n  focusY: number\n  private options: FocusPickerOptions\n\n  constructor(initializationNode: HTMLImageElement, options: FocusPickerOptions) {\n    this.options = Object.assign(DEFAULT_OPTIONS, options)\n    this.setUpElementReferences(initializationNode)\n    this.bindContainerEvents()\n    this.setUpImageAttributes()\n    this.assignStyles()\n    this.initailizeFocusCoordinates()\n    setTimeout(() => this.updateRetinaPosition(this.calculateOffsetFromFocus()), 0)\n  }\n\n  assignStyles() {\n    assignStyles(this.img, IMAGE_STYLES)\n    assignStyles(this.retina, RETINA_STYLES)\n    assignStyles(this.container, CONTAINER_STYLES)\n  }\n\n  initailizeFocusCoordinates() {\n    this.focusX = firstNumberIn([\n      this.options.focus && this.options.focus.x,\n      this.img.getAttribute(\"data-focus-x\"),\n      0,\n    ])\n\n    this.focusY = firstNumberIn([\n      this.options.focus && this.options.focus.y,\n      this.img.getAttribute(\"data-focus-y\"),\n      0,\n    ])\n  }\n\n  setUpElementReferences(initializationNode: HTMLElement | HTMLImageElement) {\n    if (initializationNode.nodeName === \"IMG\") {\n      this.img = initializationNode as HTMLImageElement\n      this.container = initializationNode.parentElement as HTMLElement\n    } else {\n      this.container = initializationNode as HTMLElement\n      this.img = initializationNode.querySelector(\"img\") as HTMLImageElement\n      if (!this.img) {\n        console.error(initializationNode)\n        throw new Error(\"No image found within above container\")\n      }\n    }\n    this.retina = document.createElement(\"img\")\n    this.retina.src = retina\n    this.retina.draggable = false\n    this.container.appendChild(this.retina)\n  }\n\n  bindContainerEvents() {\n    this.container.onmousedown = this.startDragging\n    this.container.onmouseup = this.stopDragging\n    this.container.onmouseleave = this.stopDragging\n    this.container.onmousemove = this.handleDrag\n  }\n\n  setUpImageAttributes() {\n    this.img.draggable = false\n    this.img.onload = () => {\n      this.updateRetinaPosition(this.calculateOffsetFromFocus())\n    }\n  }\n\n  calculateOffsetFromFocus = () => {\n    const { width, height } = this.img.getBoundingClientRect()\n    const offsetX = width * (this.focusX / 2 + 0.5)\n    const offsetY = height * (this.focusY / -2 + 0.5)\n    return { offsetX, offsetY }\n  }\n\n  updateRetinaPosition = (offsets: { offsetX: number; offsetY: number }) => {\n    this.retina.style.top = `calc(${offsets.offsetY}px - 10px)`\n    this.retina.style.left = `calc(${offsets.offsetX}px - 10px)`\n  }\n\n  setFocus = (x, y) => {\n    this.focusX = x\n    this.focusY = y\n    this.updateRetinaPosition(this.calculateOffsetFromFocus())\n  }\n\n  startDragging = (e: MouseEvent) => {\n    this.isDragging = true\n    this.handleDrag(e)\n  }\n\n  stopDragging = () => {\n    this.isDragging = false\n  }\n\n  handleDrag = (e: MouseEvent) => {\n    if (this.isDragging) {\n      const { width, height, left, top } = this.img.getBoundingClientRect()\n\n      // Calculate FocusPoint coordinates\n      const offsetX = e.clientX - left\n      const offsetY = e.clientY - top\n      const focusX = (offsetX / width - 0.5) * 2\n      const focusY = (offsetY / height - 0.5) * -2\n\n      this.updateRetinaPosition({ offsetX, offsetY })\n\n      this.img.setAttribute(\"data-focus-x\", focusX.toString())\n      this.img.setAttribute(\"data-focus-y\", focusY.toString())\n      this.options.onChange(focusX, focusY)\n    }\n  }\n}\n"],"names":["el","styles","key","style","values","map","value","parseFloat","find","func","debounceTime","_i","args","timeout","clearTimeout","setTimeout","debouncedFunction","FocusedImage","Object","assign","defineProperty","target","varArgs","TypeError","to","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","writable","configurable","Array","predicate","this","o","len","thisArg","k","kValue","noop","display","maxWidth","CONTAINER_STYLES","position","overflow","userSelect","RETINA_STYLES","cursor","DEFAULT_OPTIONS","onChange","initializationNode","options","_a","width","height","offsetX","_this","focusX","offsetY","focusY","offsets","retina","top","left","x","y","updateRetinaPosition","calculateOffsetFromFocus","e","isDragging","handleDrag","top_1","clientX","clientY","img","setAttribute","toString","setUpElementReferences","bindContainerEvents","setUpImageAttributes","assignStyles","initailizeFocusCoordinates","FocusPicker","IMAGE_STYLES","container","firstNumberIn","focus","getAttribute","nodeName","parentElement","querySelector","console","error","Error","document","createElement","src","draggable","appendChild","onmousedown","startDragging","onmouseup","stopDragging","onmouseleave","onmousemove","onload","IMG_STYLES","minHeight","minWidth","right","bottom","updateOnWindowResize","setFocusAttributes","applyShift","hasReferences","checkForStaticPosition","imageW","naturalWidth","imageH","naturalHeight","containerW","getBoundingClientRect","containerH","hShift","vShift","wR","hR","maxHeight","calcShift","setUpStyles","debounceApplyShift","debounce","startListening","listening","window","addEventListener","removeEventListener","warn","__focal_point_instance__","stopListening","conToImageRatio","containerSize","imageSize","focusSize","toMinus","containerCenter","Math","floor","focusFactor","scaledImage","focusOffset","remainder","containerRemainder"],"mappings":"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"}